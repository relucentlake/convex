---
date: 
author:
- Е.А. Роганов
title: Модификация проекта «Выпуклая оболочка»
---

### Постановка задачи

Необходимо модифицировать код эталонного проекта таким образом, чтобы
программа индуктивно вычисляла сумму расстояний от заданной точки до
вершин выпуклой оболочки.

### Обсуждение идеи решения

Метод `g` (так мы назовём метод, который будет возвращать требуемую сумму
расстояний) должен возвращать `None` для нульугольника, так как в этом
случае отсутствуют вершины выпуклой оболочки. Для одноугольника и
двуугольника `g` легко находится, а для многоугольника вычисление
легко реализовать, вычитая из суммы расстояний `_g` расстояния до
удаляемых вершин и добавляя расстояние до включаемой вершины при
изменении выпуклой оболочки.

В классе `Figure` целесообразно определить переменную (атрибут) класса
`fixed_point` — это будет та самая точка, сумма расстояний от которой до
вершин выпуклой оболочке будет находиться. Python позволяет не делать этого
при определении класса, поэтому можно задание её координат выполнять
в файлах запуска и тестах.

Определение в классе `Figure` метода `g`, возвращающего `None`, позволяет
не переопределять этот метод в классе `Void`. Для классов `Point` и `Segment`
метод `g` легко определяется, а в код класса `Polygon` необходимо внести
определённые изменения.

В тесты необходимо добавить несколько методов, которые будут иллюстрировать
правильность выполненной модификации. Можно, например, рассмотреть одноугольник
и двуугольник, для которых значение функции `g` легко находится устно.
Затем надо добавлять такие точки к двуугольнику, чтобы:

- новые рёбра добавлялись;
- новые рёбра удалялись;
- для всех получаемых выпуклых оболочек значение функции `g` легко
  вычислялось.

Скопируем директорию `convex` с файлами эталонного проекта в директорию
`m2_convex`, в которой будет выполняться работа по модификации проекта.

### Первый этап — работа с одноугольником и двуугольником

Целесообразно начать с изменения тестов — это позволит затем проверить
(хотя бы до некоторой степени) корректность модификации кода этих
двух классов.

#### Модификация тестов

В методы `setup_method` необходимо добавить инициализацию точки
`fixed_point`, от которой вычисляется сумма расстояний до вершин
выпуклой оболочки:

~~~ {.py}
    def setup_method(self):
        Figure.fixed_point = R2Point(1.0, 0.0)
~~~

Для разных классов координаты этой точки можно указывать различными.

#### Модификация кода

В класс `Figure` (файл `convex.py`) добавим метод `g`:

~~~ {.py}
    def g(self):
        return None
~~~

В классaх `Point` и `Segment` этот метод надо переопределить.

#### Запуск тестов

Убеждаемся в правильности выполненной модификации, выполняя команду

    python -B -m pytest -p no:cacheprovider tests/test_convex.py 
 
### Второй этап — работа с многоугольником

#### Модификация тестов

Идея модификации была описана выше. С кодом методов, добавленных в класс
`TestPolygon`, можно ознакомиться в файле `test_convex.py`. 

> Рекомендуется нарисовать (на бумаге) картинку. Она поможет понять тесты.

#### Модификация кода

Результат — в файле `convex.py`.
 
### Третий этап — модификация файлов запуска

В файлах `run_convex.py` и `run_tk_convex.py` кроме добавления печати
значений вычисляемого метода `g` необходимо обеспечить ввод координат
точки, от которой будет вычисляться сумма расстояний до вершин
выпуклой оболочки.

### Четвёртый этап — проверка соблюдения соглашений о стиле программного кода

Эту команду следует выполнить, находясь в директории `m1_convex`.

    find . -name '*.py' -exec pycodestyle {} \;
 
### Что же было сделано?

Полный перечень внесённых в эталонную версию проекта изменений, можно
получить с помощью команды `diff` с опцией `-r`, выполнять которую следует
находясь в родительской по отношению к `convex` и `m2_convex` директориям):

    diff -r m2_convex convex

Вот результат:

~~~
diff -r m2_convex/convex.py convex/convex.py
14,16d13
<     def g(self):
<         return None
< 
34,36d30
<     def g(self):
<         return self.p.dist(self.fixed_point)
< 
57,59d50
<     def g(self):
<         return self.fixed_point.dist(self.p) + self.fixed_point.dist(self.q)
< 
75,76d65
<         self._g = a.dist(self.fixed_point) + b.dist(self.fixed_point) + \
<             c.dist(self.fixed_point)
84,86d72
<     def g(self):
<         return self._g
< 
110d95
<                 self._g -= p.dist(self.fixed_point)
119d103
<                 self._g -= p.dist(self.fixed_point)
127d110
<             self._g += t.dist(self.fixed_point)
diff -r m2_convex/run_convex.py convex/run_convex.py
3,7c3
< from convex import Figure, Void
< 
< print("Заданная точка")
< Figure.fixed_point = R2Point()
< print("\nТочки плоскости")
---
> from convex import Void
13c9
<         print(f"S = {f.area()}, P = {f.perimeter()}, g = {f.g()}")
---
>         print(f"S = {f.area()}, P = {f.perimeter()}")
diff -r m2_convex/run_tk_convex.py convex/run_tk_convex.py
4,8c4
< from convex import Figure, Void, Point, Segment, Polygon
< 
< print("Заданная точка")
< Figure.fixed_point = R2Point()
< print("\nТочки плоскости")
---
> from convex import Void, Point, Segment, Polygon
26c22
<         print(f"S = {f.area()}, P = {f.perimeter()}, g = {f.g()}")
---
>         print(f"S = {f.area()}, P = {f.perimeter()}")
Только в m2_convex: solution.html
Только в m2_convex: solution.md
diff -r m2_convex/tests/test_convex.py convex/tests/test_convex.py
39d38
<         Figure.fixed_point = R2Point(1.0, 0.0)
65,68d63
<     # Функция `g` вычисляется корректно
<     def test_g(self):
<         assert self.f.g() == approx(1.0)
< 
75d69
<         Figure.fixed_point = R2Point(0.5, 0.0)
105,108d98
<     # Функция `g` вычисляется корректно
<     def test_g(self):
<         assert self.f.g() == approx(1.0)
< 
119d108
<         Figure.fixed_point = R2Point(0.0, 0.0)
176,232d164
< 
<     # Функция `g` вычисляется корректно для треугольника
<     def test_g1(self):
<         t = Segment(R2Point(-1.0, 0.0), R2Point(1.0, 0.0))
<         t = t.add(R2Point(0.0, 1.0))
<         assert t.g() == approx(3.0)
< 
<     # Функция `g` вычисляется корректно для квадрата
<     def test_g2(self):
<         t = Segment(R2Point(-1.0, 0.0), R2Point(1.0, 0.0))
<         t = t.add(R2Point(0.0, 1.0))
<         t = t.add(R2Point(0.0, -1.0))
<         assert t.g() == approx(4.0)
< 
<     # Функция `g` вычисляется корректно для трапеции
<     def test_g3(self):
<         t = Segment(R2Point(-1.0, 0.0), R2Point(1.0, 0.0))
<         t = t.add(R2Point(0.0, 1.0))
<         t = t.add(R2Point(0.0, -1.0))
<         t = t.add(R2Point(1.0, 1.0))
<         assert t.g() == approx(4.0 + sqrt(2.0))
< 
<     # Функция `g` вычисляется корректно для прямоугольника
<     def test_g4(self):
<         t = Segment(R2Point(-1.0, 0.0), R2Point(1.0, 0.0))
<         t = t.add(R2Point(0.0, 1.0))
<         t = t.add(R2Point(0.0, -1.0))
<         t = t.add(R2Point(1.0, 1.0))
<         t = t.add(R2Point(1.0, -1.0))
<         t = t.add(R2Point(-1.0, 1.0))
<         t = t.add(R2Point(-1.0, -1.0))
<         assert t.g() == approx(4.0 * sqrt(2.0))
< 
<     # Функция `g` вычисляется корректно для большой трапеции
<     def test_g5(self):
<         t = Segment(R2Point(-1.0, 0.0), R2Point(1.0, 0.0))
<         t = t.add(R2Point(0.0, 1.0))
<         t = t.add(R2Point(0.0, -1.0))
<         t = t.add(R2Point(1.0, 1.0))
<         t = t.add(R2Point(1.0, -1.0))
<         t = t.add(R2Point(-1.0, 1.0))
<         t = t.add(R2Point(-1.0, -1.0))
<         t = t.add(R2Point(3.0, -1.0))
<         assert t.g() == approx(3.0 * sqrt(2.0) + sqrt(10.0))
< 
<     # Функция `g` вычисляется корректно для большого треугольника
<     def test_g6(self):
<         t = Segment(R2Point(-1.0, 0.0), R2Point(1.0, 0.0))
<         t = t.add(R2Point(0.0, 1.0))
<         t = t.add(R2Point(0.0, -1.0))
<         t = t.add(R2Point(1.0, 1.0))
<         t = t.add(R2Point(1.0, -1.0))
<         t = t.add(R2Point(-1.0, 1.0))
<         t = t.add(R2Point(-1.0, -1.0))
<         t = t.add(R2Point(3.0, -1.0))
<         t = t.add(R2Point(-1.0, 3.0))
<         assert t.g() == approx(sqrt(2.0) + 2 * sqrt(10.0))
~~~